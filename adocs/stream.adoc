# ストリーム処理入門以前　〜この夏はじめる♪ストリーム処理ことはじめ〜


## はじめに
本誌ではストリーム処理処理について取り上げます。
Apache SparkやApache Stormをはじめ、ストリーム処理を実現するOSSが最近注目を集めています。
そのため、なんとなくストリーム処理について聞いたことがあるといった方も多いのではないでしょうか。

実際にストリーム処理をシステムとして実現するためにはこの処理ならではの様々な考慮ポイントがあります。

そこで本誌ではそもそもストリーム処理とはどういったものなのかから始め、ストリーム処理システムを構築するにあたってのポイントを中心にみていきます。

//-------------------------------------------------------------------------

## 対象読者
本誌はこれからストリーム処理について勉強してみようという方を対象にしています。
そのため、ストリーム処理を実現する特定のプロダクトには特化せず、ストリーム処理そのものについて記載しています。

//-------------------------------------------------------------------------

<<<

## ストリーム処理ってなんだろう
### ストリーム処理ってなに？
まずはこれから扱うストリーム処理がどういったものなのかを整理してみましょう。 +
本誌ではストリーム処理について以下の定義で話を進めていこうかと思います。

[quote]
刻々と生成されるデータ(ストリームデータ)をその都度、もしくは短い時間幅で取り込んで処理する

ストリーム処理が対象とするストリームデータには以下のような特徴があります。(Figure1)

* 連続的/継続的に発生
* ひとつひとつのデータサイズは少量(なことが多い)

ストリームデータについて、センサーデータを例に考えてみます。 +
温度センサーや湿度センサーなどはその時々の温度/湿度データを連続して生成します。
これらのセンサーが生成するデータはひとつひとつはとても小さいものです。

センサーデータ以外にも、ECサイトなどのWebサイトで生成されるログデータもストリームデータとしての特性があります。 +
日々多くのユーザによって行われる様々な操作はログとして連続的/継続的に生成されます。
こうしたログデータもひとつひとつのデータサイズは小さいものです。

.ストリームデータの特徴
image::/Users/keigo/Projects/github.com/keigodasu/writing/resources/images/02.png[width=800]

ストリーム処理ではこうしたストリームデータに対して処理を施していきます。(Figure2)

センサーデータの例でいうと、センサーから送信させるデータに対してその都度閾値をチェックしたり、
その都度の直近の平均値を算出したりといったことが可能となります。 +
はたまた、ECサイトの例では、ユーザの購買履歴のログからより早く世間のトレンドを把握できたり、
ユーザーの不正操作などを早期に検知することができるようになります。

.ストリーム処理の特徴
image::/Users/keigo/Projects/github.com/keigodasu/writing/resources/images/01.png[width=800]


### バッチ処理とは何がちがうの？

ストリーム処理とは逆の処理アプローチを行うのがバッチ処理です。 +
もちろん、バッチ処理が対象とするデータにはストリームデータも含まれます。
ただしバッチ処理はそうしたストリームデータも貯めたのち、まとめて処理するといった特徴があります。 +
そのため、その都度処理するストリーム処理に対して、まとめて処理を行うためストック型の処理といったりすることもあります。

.バッチ処理の特徴
image::/Users/keigo/Projects/github.com/keigodasu/writing/resources/images/03.png[width=800]

バッチ処理と比較したストリーム処理のメリットは、先ほども述べたとおりより早く結果を得て、フィードバックにつなげられることです。

それではバッチ処理のメリットとはなんでしょうか。 +
厳密に比較を行うと多くの違いはありますが、後述するストリーム処理ならではの考慮点からすると、ある静止点をもってあとは一気に処理ができる点がひとつあげられます。

ストリーム処理でポイントとなってくるのが、いかに確実に正確に断続的に発生するストリームデータを処理できるのかといった点があります。
ストリームデータの特性上、連続的/断続的にデータが発生し続けるため、ストリーム処理ではそれらのストリームデータをどこまで処理できたか、そもそもストリームデータを受け取れたのかといった様々な
状態を管理する必要があります。

一方バッチ処理では、数時間に1回、日次など処理のサイクルが長いため、ある程度時間の余裕をもって確実にデータをシステムへ届けられればよいですし、バッチ処理開始時点までのデータを対象として/処理を実施すればよいので、ストリーム処理のように細々と状態を管理しなくてもよくなります。
(実際のバッチシステムを構築するとなると、一概にはこのようにきっぱりとはいかないことも多いです・・・)　

[options="header"]
[frame="topbot",grid="none"]
|===
|処理方式|処理の間隔|処理データ量
|ストリーム処理 |短い(発生データをより逐次的に処理)|少量
|バッチ処理 |長い(データを貯めてまとめて処理)|大量
|===

ここまではストリーム処理とはどういったものなにかについてみてきました。 +
それではつぎに、よりシステム的な観点でストリーム処理の特徴についてみていきましょう。

//-------------------------------------------------------------------------

<<<

## ストリーム処理を実現するためのシステム的観点
ストリーム処理はそれを実現するための処理方式やシステム制約など、様々な考慮ポイントが存在します。 +
ここでは、ストリーム処理をシステムとして実現するためのポイントについてみていきます。

世の中には数多くのストリーム処理エンジンと呼ばれるようなOSSがありますが、これから見ていくポイントに対応する様々な特徴の違いがあります。
採用するプロダクトを選ぶにあたって、着目すべきポイントにもなってくる内容でもあります。


### ストリーム処理のシステム的な考慮ポイント
ストリーム処理のシステム観点でのポイントとしては主に以下のようなものがあります。

* *ストリームデータの処理方式*
* *ストリームデータのバッファリング/キューイング*
* *ストリームデータの発生時間と処理実施時間*
* *ストリームデータ処理の信頼性*

それではひとつずつ見ていきましょう。

#### ストリームデータの処理方式
さきほどストリーム処理とは時事刻々と発生するデータ(ストリームデータ)を短い時間幅で処理すると説明しました。 +
実はそのデータのストリーム処理方式には大きく2つのやり方があります。

[options="header"]
[frame="topbot",grid="none"]
|===
|処理のやり方|説明|主要プロダクト
|逐次処理 |データが到着するつど処理を行う|Storm
|マイクロバッチ処理 |短い間隔でデータをまとめて処理を行う|Spark Streaming
|===

逐次処理はストリームデータをその都度、各ストリームデータ単位に処理を実施します。 +
こうした特徴から、ひとつひとつのストリームデータを低レイテンシで処理して結果をえることが得意です。 +
こうした処理を行う代表的なOSSプロダクトにはTwitter社が開発したApache Stormがあります。 +

.逐次処理
image::/Users/keigo/Projects/github.com/keigodasu/writing/resources/images/04.png[width=800]

一方マイクロバッチ方式では、ストリームデータをその都度処理するのでなく、データをまとめて処理します。 +
これだけきくと通常のバッチ処理と変わらないようにも思えます。
しかし、マイクロバッチ処理はより短いサイクルでこのバッチ処理をまわしていきます。 +
このように短いサイクルで高頻度にバッチ処理を繰り返していくことでストリーム処理を実現していきます。 +
マイクロバッチ処理では、直近発生したデータを塊で処理していくので、複数データをまとめて取り扱うような集計処理を得意としています。 +
マイクロバッチでストリーム処理を実現するOSSプロダクトにはApahce SparkのSpark Streamingがあります。

.マイクロバッチ処理
image::/Users/keigo/Projects/github.com/keigodasu/writing/resources/images/05.png[width=800]

このように、ストリーム処理エンジンによって処理方式が異なるため、どういった処理を実現したいかに
応じて、適切なプロダクトを選定していくことになります。

[NOTE]
.コラム　マイクロバッチ処理　≠　ストリーム処理
=====================================================================
本誌ではストリーム処理の処理方式としてマイクロバッチについて説明しました。
上述した通り、マイクロバッチ方式では短い間隔でバッチ処理を実施し、擬似的にストリーム処理を実現しています。
そのため、正確にはストリーム処理ではなく、バッチ処理に分類されます。
ただ、その性質からもストリーム処理とバッチ処理の中間的な位置づけとも捉えることができます。

最近ではApache Sparkのようなマイクロバッチ方式でストリーム処理を実現するようなプロダクトも
多く利用されているため、本誌ではマイクロバッチもストリーム処理として取り扱っています。

// マイクロバッチのベン図
image::/Users/keigo/Projects/github.com/keigodasu/writing/resources/images/06.png[width=800]

=====================================================================


#### ストリームデータのバッファリング/キューイング
ストリームデータには以下の特性があることについて説明しました。

* 連続的/継続的に発生する
* ひとつひとつのデータのサイズは少量

センサーデータのようにひとつひとつのデータサイズは小さいものの、多くのセンサーデバイスからデータが送信されてくるような場合、ストリーム処理エンジン側では直接受けきれない可能性があります。

一つ一つのデータは小さくとも、それが同時にしかも大量に押し寄せてくるとストリーム処理エンジン側でシステムリソースの割り当てが間に合わず、しだいに未処理データが蓄積されていって、処理遅延が次第に大きくなっていきます。

処理が遅延するだけでなく、あまりにさばききれない場合、ストリーム処理エンジン自体がダウンして
しまうおそれもあります。

こうした事態を防ぐ方法としてストリーム処理でもバッファリング/キューイングを考慮する必要があります。

// バッファリングの役割の概念図をいれる
image::/Users/keigo/Projects/github.com/keigodasu/writing/resources/images/07.png[width=800]

例えばApache Kafkaはバッファリングとしても機能するメッセージングシステムです。
Kafkaは様々なプロダクトと連携するためのコネクタプラグインが充実しているため、最近ではKafka+何かしらのストリーム処理エンジンのセットでシステムが構築される事例も多いです。

本誌ではメッセージングシステムの詳細についてはふれませんが、このようなシステム構成を考慮することで大量のストリームデータが発生してしまってもストリーム処理システムの負荷を緩和させることが可能です。

またメッセージングシステム本来の機能として、処理に必要なデータのみをストリーム処理エンジン側で取得して処理することも可能となります。

// Pub/Subの説明をいれす
image::/Users/keigo/Projects/github.com/keigodasu/writing/resources/images/071.png[width=800]


#### ストリームデータの発生時間と処理実施時間
ストリーム処理は流れてくるストリームデータを短い時間幅で処理することで、より早く結果を得ることができるというメリットについてはすでに述べた通りです。

しかし、実際にストリーム処理によるシステムを構築する際は、あらゆるシステム制約により必ずしも発生したストリームデータを即時に処理できないケースも起こりえます。

例えば、ストリームデータ送信されている途中でネットワーク障害等により一時的に配信遅延が発生してしまような場合、ストリームデータが発生した時刻とそれが実際にストリーム処理されて結果えられた時間に乖離がでてしまいます。

// data skewの図をいれて説明する
image::/Users/keigo/Projects/github.com/keigodasu/writing/resources/images/08.png[width=800]

上の図の横軸は実際にストリームデータが発生した時刻、縦軸は発生したストリームデータがストリーム処理エンジンで受信して処理が完了した時間です。

理想は発生したストリームデータは即時にストリーム処理エンジンに届き処理されて結果が得られることです。 +
しかし先ほどの例のように、実際のシステムには様々なそれを妨げる多くの制約が起こりえます。

例えば、 +

* システム間のネットワークが不安定
* データ送信元でデータが滞留
* ストリーム処理エンジン内部で処理遅延

などなど、ストリームデータの発生時間とそれがストリーム処理されるまでのタイムラグにつながる要因は様々です。

どの程度までこうした時間的な差異が許容されるのかといった業務要件や、また差異を縮めるためにどの程度までシステムに落とし込めるのかといったか考慮しつつ、システムを構築していく必要があります。

<<<

#### ストリームデータ処理の信頼性
それでは最後にストリームデータ処理そのものの信頼性について考えてみましょう。 +
ここでいう信頼性とはストリームデータをいかに確実/正確に処理することができるのかの度合いを意味します。

こうした信頼性は一般的にメッセージの信頼性といわれたりします。 +
このメッセージの信頼性はストリームデータを処理する側だけでなく、そのストリームデータを送信する側でも考慮が必要となってきます。

一般的にはメッセージの信頼性には以下の3種類あります。

[options="header"]
[frame="topbot",grid="none"]
|===
|名前|説明
|at most once|最大1回のみ送信する。そのため、1回のみ送信するがそれが相手に届くかどうかは保証されない。
|at lest once|少なくとも1回は相手に届ける。そのため、相手に確実に1回は届けるが、
同じメッセージが重複して送られてしまうかもしれない。
|exactly once|正確に1回のみ届ける。そのため、上記の2つとは異なり、重複もなく確実に相手に1回
メッセージを届けることが可能。
|===

下にいくほどより確実に相手にデータを届けることができるため、データ送信の確実度は高くなっていきます。 +
ただし、「at least once」の場合、確実にデータが届けられるものの、そのために実は相手に届いているのに、同じデータを何度か送信してしまい、ふたたびストリーム処理エンジン側で同じデータが処理されてしまうことが考えらます。 +
そのため、処理の正確さという観点では唯一条件を満たせるのは「exactly once」に基づいた処理です。

.at most once
image::/Users/keigo/Projects/github.com/keigodasu/writing/resources/images/09.png[width=700]

.at least once
image::/Users/keigo/Projects/github.com/keigodasu/writing/resources/images/10.png[width=700]

.exactly once
image::/Users/keigo/Projects/github.com/keigodasu/writing/resources/images/11.png[width=700]

ここまでの特徴だけで比較すると常にexactley once方式に基づいた処理が望ましいように思えます。 +
もちろんそれが理想なのですが、システム観点だと正確さ、確実さを追求していくと実装コストが大きくなりがちです。

*at most once* の場合、ストリームデータの送信側はとりあえずデータをストリーム処理エンジンめがけて送信するだけでよく、それが確実に届いたかについては気を払う必要はありません。 +
また、ストリーム処理エンジン側も届いたデータだけを処理していけばよいだけです。

.「at most once」の処理フロー
image::/Users/keigo/Projects/github.com/keigodasu/writing/resources/images/12.png[width=800]

一方「at least once」の場合、ストリーム処理エンジンへ確実にデータを届けるためには、正常にやりとりが完了したかをお互いに知る必要があります。 +
そのため、ストリーム処理エンジンは正常にデータを受け取れた場合にそのデータの送信元へその旨を通知する必要があります。

また、万が一ストリーム処理エンジンにデータが届かなかった場合、再度同じデータを送信してもらう(リトライ)の考慮も必要となってきます。 +
さらに、「exactly once」を実現するためには、上記の仕組みに加えて、ストリーム処理エンジン側で全く同一のデータが送信されてきても、そうした重複を排除する仕組みも必要となります。 +
重複を排除するためには、各ストリームデータを一意に特定できるようなIDなどをもとにして、各ストリームデータの状態も管理しておく必要があります。

.「at least once/exactly once」の処理フロー
image::/Users/keigo/Projects/github.com/keigodasu/writing/resources/images/14.png[width=800]

このようにより確実性/正確性を求めるためには、その分ストリーム処理の実装難易度や考慮ポイントもどんどん増えていくこととなります。 +
また、管理する状態や整合性を維持しなくてはいけない対象が増えるほど、ストリーム処理そのものの性能も落ちていってしまいます。

ストリーム処理エンジンのOSSごとにサポートするメッセージの信頼性は異なってくるため、実現したい要件とも照らし合わせて、適切なシステム設計を行う必要があります。

//-------------------------------------------------------------------------


## さいごに
本誌では具体的なプロダクトの説明よりかは、それ以前のストリーム処理の考え方や、実装にあたって考慮すべき要件などのポイントを中心にみてきました。 +
こうした観点をもとに業務要件に適したシステム設計と最適なプロダクト選びに少しでも力になれましたら光栄です。
